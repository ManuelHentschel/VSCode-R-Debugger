# File Structure

Since there have been some significant changes to the project structure lately,
this .md file is meant to give an overview over the (important) files in each repo.

## VSCode-R-debugger
Communication with VS Code happens through requests, responses, and events specified in the [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/).
This extension itself is mostly just a wrapper that starts an R process and passes protocol messages through to R.
Some functions (like flow control in the `browser()`) are currently not implemented in R itself and are also handled by this extension.

In `package.json` and `src/extension.ts` the properties, settings, and capabilities of the extension are described for VS-Code.

In `src/debugSession.ts` mostly just passes messages from the DAP through to the specific handler functions in `src/debugRuntime.ts`.

The file `src/debugRuntime.ts` has four main functionalities:
* Initializing an R session, happening mostly in `initializeRequest()`
* Parsing the output of the R process, happening mostly in `handleLine()` and `handleJSON`
* Handling flow control (stepping through the code line by line), happening in `continue()`, `step()` etc.
* Handling output to the debug console that does not come directly from the debugger

The file `src/rSession` is responsible for actually launching an R process and sending commands to the R process.
Arguments to the R process are converted from typescript objects to nested calls to `list(...)`, which should probably replaced by JSONs in the future.


## vscDebugger


The important files are contained in four directories:
* `R`: The actual R code
* `src`: The C code used to get info about promises and ellipses
* `man`: Regular man files (documentation) generated by roxygen
* `d.ts`: Typescript declaration files.
These files do not have any actual effect on the package itself.
Instead, they document the types and structures of the most important R functions used.
They are meant to document some functions and keep track of the content of (custom) protocol messages etc..
Most `.d.ts` files correspond to an `.R` file of the same name.

A brief overview of what is in each R file:
* `global.R`: Definition of global `session` variable and `.onLoad()` function to configure the package on startup.
* `debugAdapter.R`: Handles communication with VS-Code through the DAP.
These functions don't perform any significant computation or analysis and
mostly just transforms messages/arguments.
* `helpers.R`: General functions that perform significant computation/analysis on the R-level but "know" about the DAP.
* `utils.R`: General functions that are completely independent from the DAP.
* `launch.R`: The handling of initialize and launch requests, setting up the current debug session
* `buildStack.R`: Functions used to gather info about the stack, frames, scopes and variables
* `buildStackHelpers.R`: Functions (mostly) used in `buildStack.R`
* `lazyTree.R`: Data structure used to store info about stack, frames etc. (see below)
* `getStack.R`: Functions used to answer requests about stack, frames etc. that just retrieve the significant info from results computed by `buildStack.R`
* `getStackHelpers.R`: Functions (mostly) used in `getStack.R`
* `breakpointManagement.R`: Functions to handle the storage and updating of breakpoints
* `breakpoints.R`: Actual setting of breakpoints in R functions
* `completions.R`: Functions used to handle completion requests (used to provide completions for text entered into the debug console)
* `customVarInfo.R`: Functions to manage the creation and retrieval of `VarInfos`
(used to describe `value`, `type` etc. of variables)
* `defaultVarInfos.R`: A list of `varInfo`s to describe most variables in a sensible way
* `defaultVarInfoHelpers.R`: Functions used in `defaultVarInfos.R`
* `debugSource`: Function to source a file with breakpoints
* `evaluate`: Functions used to evaluate text entered into the debug console, and watch-expression



### Note on lazyTree.R

The gathering of info about the stack tree has been somewhat messy so far, because we want to provide a great level of detail
(especially for deeply nested data structures),
but computing all these infos on each step would be too expensive
(considering e.g. the large number of functions in `base` alone).

In order to separate the production of information about the content of R variables
from the management of storage and computational effort, all frames, scopes, and variables are stored in a "lazy Tree".
A rather detailed declaration file (including a non-lazy base class) is provided as `lazyTree.d.ts`.

As in a normal tree, data is stored in nodes that have parent and children nodes
(e.g. frame -> scope(s) -> variable(s)):
``` ts
interface Node {
    nodeId: NodeId;
    parentId: NodeId;
    childrenIds: NodeId[];
    contentContent?: Content;
}
```
Content can be accessed by functions `getContent`, `getContents` and assigned by `storeTo[New]Node`.
The structure of the tree can be accessed and modified through "standard" functions (`getParentId` etc.).

The standard Tree concept is extended by LazyTree, by not immediately storing the content of a node, but the arguments used to produce it.
When creating a LazyTree, two functions, `contentFunction` and `childrenFunction`, must be provided to do so.
The standard tree node is extended by the following properties:

``` ts
interface LazyNode extends Node {
    childrenReady: boolean;
    childrenArgs?: ChildrenArgs;
    contentReady: boolean;
    contentProducesChildren: boolean;
    contentArgs: ContentArgs;
}
```
When e.g. a scope  is stored to the tree, its properties are not computed immediately.
Instead, the corresponding R environment is stored as `contentArgs` and `contentReady` is set to `false`.
Only if info about this specific scope is requested by the debugger, the `contentArgs` are passed to `contentFunction()`, the result is stored for later use and does not need to be computed each time.
The children of a node are computed similarly using `childArgs` and the `childrenFunction`.

When storing to the tree or retrieving data from the tree, one should (ideally) not have to worry about the "lazy" structure behind it and just treat it like a non-lazy tree
(with the difference of assigning arguments instead of the content/children itself).

Disclaimer: The entire file is new and not tested properly and definitely not "guaranteed" to behave as expected.


